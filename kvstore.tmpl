{{- /*gotype: github.com/ehsundar/kvstore.kvstoreTemplateContext*/ -}}
// Code generated by protoc-gen-go-kvstore. DO NOT EDIT.

package example

import (
	"context"
	"errors"
	"fmt"
	"time"

	"github.com/redis/go-redis/v9"
	"google.golang.org/protobuf/encoding/protojson"
)

{{range $_, $pairSpecs := .Pairs}}
{{$codeSafeName := $pairSpecs.CodeSafeName}}
// generated code for {{$codeSafeName}}
// storage interface

type {{$codeSafeName}}KVStore interface {
	Get(context.Context, *{{$pairSpecs.KeySpecs.MessageName}}, ...{{$codeSafeName}}GetOption) (*{{$pairSpecs.ValueSpecs.MessageName}}, error)
	Set(context.Context, *{{$pairSpecs.KeySpecs.MessageName}},
		*{{$pairSpecs.ValueSpecs.MessageName}}, ...{{$codeSafeName}}SetOption) (*{{$pairSpecs.ValueSpecs.MessageName}}, error)
	Del(context.Context, *{{$pairSpecs.KeySpecs.MessageName}}) error
	{{if $pairSpecs.ValueSpecs.NumericInt}}Incr(context.Context, *{{$pairSpecs.KeySpecs.MessageName}}, int, ...{{$codeSafeName}}IncrOption) (int, error){{end}}
	{{if $pairSpecs.ValueSpecs.NumericFloat}}Incr(context.Context, *{{$pairSpecs.KeySpecs.MessageName}}, float64, ...{{$codeSafeName}}IncrOption) (float64, error){{end}}
}

// get options
type {{$codeSafeName|untitle}}GetOptionContext struct{
	ttl  time.Duration
	exAt time.Time
	del  bool
}

type {{$codeSafeName}}GetOption func(o *{{$codeSafeName|untitle}}GetOptionContext)

func With{{$codeSafeName}}GetTTL(ttl time.Duration) {{$codeSafeName}}GetOption {
	return func(o *{{$codeSafeName|untitle}}GetOptionContext) {
		o.ttl = ttl
		o.exAt = time.Time{}
		o.del = false
	}
}

func With{{$codeSafeName}}GetExpireAt(eat time.Time) {{$codeSafeName}}GetOption {
	return func(o *{{$codeSafeName|untitle}}GetOptionContext) {
		o.exAt = eat
		o.ttl = 0
		o.del = false
	}
}

func With{{$codeSafeName}}Del() {{$codeSafeName}}GetOption {
	return func(o *{{$codeSafeName|untitle}}GetOptionContext) {
		o.del = true
		o.ttl = 0
		o.exAt = time.Time{}
	}
}

// set options
type {{$codeSafeName|untitle}}SetOptionContext struct{
	ttl     time.Duration
	exAt    time.Time
	mode    string
	get     bool
	keepTTL bool
}

type {{$codeSafeName}}SetOption func(o *{{$codeSafeName|untitle}}SetOptionContext)

func With{{$codeSafeName}}SetOnlyIfNotExists() {{$codeSafeName}}SetOption {
	return func(o *{{$codeSafeName|untitle}}SetOptionContext) {
		o.mode = "NX"
	}
}

func With{{$codeSafeName}}SetOnlyIfAlreadyExists() {{$codeSafeName}}SetOption {
	return func(o *{{$codeSafeName|untitle}}SetOptionContext) {
		o.mode = "XX"
	}
}

func With{{$codeSafeName}}RetieveDisabled() {{$codeSafeName}}SetOption {
	return func(o *{{$codeSafeName|untitle}}SetOptionContext) {
		o.get = false
	}
}

func With{{$codeSafeName}}SetTTL(ttl time.Duration) {{$codeSafeName}}SetOption {
	return func(o *{{$codeSafeName|untitle}}SetOptionContext) {
		o.ttl = ttl
		o.exAt = time.Time{}
		o.keepTTL = false
	}
}

func With{{$codeSafeName}}SetExpireAt(eat time.Time) {{$codeSafeName}}SetOption {
	return func(o *{{$codeSafeName|untitle}}SetOptionContext) {
		o.exAt = eat
		o.ttl = 0
		o.keepTTL = false
	}
}

{{if or $pairSpecs.ValueSpecs.NumericInt $pairSpecs.ValueSpecs.NumericFloat}}
// incr options
type {{$codeSafeName|untitle}}IncrOptionContext struct{
	ttl  time.Duration
	exAt time.Time
	keepTTL bool
}

type {{$codeSafeName}}IncrOption func(o *{{$codeSafeName|untitle}}IncrOptionContext)

func With{{$codeSafeName}}IncrTTL(ttl time.Duration, keepTTL bool) {{$codeSafeName}}IncrOption {
	return func(o *{{$codeSafeName|untitle}}IncrOptionContext) {
		o.ttl = ttl
		o.keepTTL = keepTTL
		o.exAt = time.Time{}
	}
}

func With{{$codeSafeName}}IncrExpireAt(eat time.Time) {{$codeSafeName}}IncrOption {
	return func(o *{{$codeSafeName|untitle}}IncrOptionContext) {
		o.exAt = eat
		o.ttl = 0
		o.keepTTL = false
	}
}
{{end}}

// storage construction

func New{{$codeSafeName}}Store(r redis.Cmdable, opts ...{{$codeSafeName|untitle}}Option) {{$codeSafeName}}KVStore {
	oc := {{$codeSafeName|untitle}}OptionContext{}

	for _, opt := range opts {
		opt(&oc)
	}

	return &{{$codeSafeName|untitle}}Storage{
		r:    r,
		opts: oc,
	}
}

type {{$codeSafeName|untitle}}OptionContext struct{}

type {{$codeSafeName|untitle}}Option func(o *{{$codeSafeName|untitle}}OptionContext)

// storage implementation

type {{$codeSafeName|untitle}}Storage struct {
	r    redis.Cmdable
	opts {{$codeSafeName|untitle}}OptionContext
}

func (s *{{$codeSafeName|untitle}}Storage) Get(
	ctx context.Context, key *{{$pairSpecs.KeySpecs.MessageName}}, opts ...{{$codeSafeName}}GetOption) (*{{$pairSpecs.ValueSpecs.MessageName}}, error) {

	var err error

	o := {{$codeSafeName|untitle}}GetOptionContext{}
	for _, opt := range opts {
		opt(&o)
	}

	k, err := key.marshal()
	if err != nil {
		return nil, err
	}

	var v string
	switch {
	case o.del:
		v, err = s.r.GetDel(ctx, k).Result()
	case o.ttl != 0:
		v, err = s.r.GetEx(ctx, k, o.ttl).Result()
	case !o.exAt.IsZero():
		// TODO: PR to go-redis for exAt
		err = errors.New("exat is not supported by go-redis")
	default:
		v, err = s.r.Get(ctx, k).Result()
	}

	if err != nil {
		return nil, err
	}

	msg := &{{$pairSpecs.ValueSpecs.MessageName}}{}
	err = msg.unmarshal(v)
	if err != nil {
		return nil, err
	}

	return msg, nil
}

func (s *{{$codeSafeName|untitle}}Storage) Set(ctx context.Context, key *{{$pairSpecs.KeySpecs.MessageName}},
	value *{{$pairSpecs.ValueSpecs.MessageName}}, opts ...{{$codeSafeName}}SetOption) (*{{$pairSpecs.ValueSpecs.MessageName}}, error) {

	o := {{$codeSafeName|untitle}}SetOptionContext{
		get:     true,
		keepTTL: true,
	}
	for _, opt := range opts {
		opt(&o)
	}

	k, err := key.marshal()
	if err != nil {
		return nil, err
	}

	mv, err := value.marshal()
	if err != nil {
		return nil, err
	}

	v, err := s.r.SetArgs(ctx, k, mv, redis.SetArgs{
		Mode:     o.mode,
		TTL:      o.ttl,
		ExpireAt: o.exAt,
		Get:      o.get,
		KeepTTL:  o.keepTTL,
	}).Result()
	if err != nil && !errors.Is(err, redis.Nil) {
		return nil, err
	}

	if v != "" {
		msg := &{{$pairSpecs.ValueSpecs.MessageName}}{}
		err = msg.unmarshal(v)
		if err != nil {
			return nil, err
		}
		return msg, nil
	}

	return nil, nil
}

func (s *{{$codeSafeName|untitle}}Storage) Del(ctx context.Context, key *{{$pairSpecs.KeySpecs.MessageName}}) error {

	k, err := key.marshal()
	if err != nil {
		return err
	}

	_, err = s.r.Del(ctx, k).Result()
	return err
}
{{if $pairSpecs.ValueSpecs.NumericInt}}
func (s *{{$codeSafeName|untitle}}Storage) Incr(ctx context.Context,
	key *{{$pairSpecs.KeySpecs.MessageName}}, by int, opts ...{{$codeSafeName}}IncrOption) (int, error) {

	o := {{$codeSafeName|untitle}}IncrOptionContext{}
	for _, opt := range opts {
		opt(&o)
	}

	k, err := key.marshal()
	if err != nil {
		return 0, err
	}

	v, err := s.r.IncrBy(ctx, k, int64(by)).Result()
	if err != nil {
		return 0, err
	}

	switch {
	case o.ttl != 0:
		if o.keepTTL {
			_, err = s.r.ExpireNX(ctx, k, o.ttl).Result()
		} else {
			_, err = s.r.Expire(ctx, k, o.ttl).Result()
		}
	case !o.exAt.IsZero():
		_, err = s.r.ExpireAt(ctx, k, o.exAt).Result()
	}

	return int(v), err
}
{{end}}
{{if $pairSpecs.ValueSpecs.NumericFloat}}
func (s *{{$codeSafeName|untitle}}Storage) Incr(ctx context.Context,
	key *{{$pairSpecs.KeySpecs.MessageName}}, by float64, opts ...{{$codeSafeName}}CallOption) (float64, error) {

	o := {{$codeSafeName|untitle}}CallOptionContext{
		get:     true,
		keepTTL: true,
	}
	for _, opt := range opts {
		opt(&o)
	}

	k, err := key.marshal()
	if err != nil {
		return 0, err
	}

	v, err := s.r.IncrByFloat(ctx, k, by).Result()
	if err != nil {
		return 0, err
	}

	switch {
	case o.ttl != 0:
		if o.keepTTL {
			_, err = s.r.ExpireNX(ctx, k, o.ttl).Result()
		} else {
			_, err = s.r.Expire(ctx, k, o.ttl).Result()
		}
	case !o.exAt.IsZero():
		_, err = s.r.ExpireAt(ctx, k, o.exAt).Result()
	}

	return v, err
}
{{end}}
// message marshallers

func (msg *{{$pairSpecs.KeySpecs.MessageName}}) marshal() (string, error) {
	{{$keyfmt := $pairSpecs.KeySpecs.KeyFormat}}
	v := fmt.Sprintf("{{$keyfmt.Format}}"{{if $keyfmt.VarNames}}, {{end}}{{$keyfmt.VarNames|funcCallArgs "msg"}})

	return v, nil
}

func (msg *{{$pairSpecs.ValueSpecs.MessageName}}) marshal() (string, error) {
	v, err := protojson.MarshalOptions{}.Marshal(msg)
	if err != nil {
		return "", err
	}

	return string(v), nil
}

func (msg *{{$pairSpecs.ValueSpecs.MessageName}}) unmarshal(value string) error {
	return protojson.UnmarshalOptions{}.Unmarshal([]byte(value), msg)
}

{{end}}
