// Code generated by protoc-gen-go-kvstore. DO NOT EDIT.

package example

import (
	"context"
	"errors"
	"fmt"
	"time"

	"github.com/redis/go-redis/v9"
	"google.golang.org/protobuf/encoding/protojson"
)

// generated code for FeatureX
// storage interface

type FeatureXKVStore interface {
	Get(context.Context, *StaticKey, ...FeatureXGetOption) (*ValueForStaticKey, error)
	Set(context.Context, *StaticKey,
		*ValueForStaticKey, ...FeatureXSetOption) (*ValueForStaticKey, error)
	Del(context.Context, *StaticKey) error
}

// get options
type featureXGetOptionContext struct {
	ttl  time.Duration
	exAt time.Time
	del  bool
}

type FeatureXGetOption func(o *featureXGetOptionContext)

func WithFeatureXGetTTL(ttl time.Duration) FeatureXGetOption {
	return func(o *featureXGetOptionContext) {
		o.ttl = ttl
		o.exAt = time.Time{}
		o.del = false
	}
}

func WithFeatureXGetExpireAt(eat time.Time) FeatureXGetOption {
	return func(o *featureXGetOptionContext) {
		o.exAt = eat
		o.ttl = 0
		o.del = false
	}
}

func WithFeatureXDel() FeatureXGetOption {
	return func(o *featureXGetOptionContext) {
		o.del = true
		o.ttl = 0
		o.exAt = time.Time{}
	}
}

// set options
type featureXSetOptionContext struct {
	ttl     time.Duration
	exAt    time.Time
	mode    string
	get     bool
	keepTTL bool
}

type FeatureXSetOption func(o *featureXSetOptionContext)

func WithFeatureXSetOnlyIfNotExists() FeatureXSetOption {
	return func(o *featureXSetOptionContext) {
		o.mode = "NX"
	}
}

func WithFeatureXSetOnlyIfAlreadyExists() FeatureXSetOption {
	return func(o *featureXSetOptionContext) {
		o.mode = "XX"
	}
}

func WithFeatureXRetieveDisabled() FeatureXSetOption {
	return func(o *featureXSetOptionContext) {
		o.get = false
	}
}

func WithFeatureXSetTTL(ttl time.Duration) FeatureXSetOption {
	return func(o *featureXSetOptionContext) {
		o.ttl = ttl
		o.exAt = time.Time{}
		o.keepTTL = false
	}
}

func WithFeatureXSetExpireAt(eat time.Time) FeatureXSetOption {
	return func(o *featureXSetOptionContext) {
		o.exAt = eat
		o.ttl = 0
		o.keepTTL = false
	}
}

// storage construction

func NewFeatureXStore(r redis.Cmdable, opts ...featureXOption) FeatureXKVStore {
	oc := featureXOptionContext{}

	for _, opt := range opts {
		opt(&oc)
	}

	return &featureXStorage{
		r:    r,
		opts: oc,
	}
}

type featureXOptionContext struct{}

type featureXOption func(o *featureXOptionContext)

// storage implementation

type featureXStorage struct {
	r    redis.Cmdable
	opts featureXOptionContext
}

func (s *featureXStorage) Get(
	ctx context.Context, key *StaticKey, opts ...FeatureXGetOption) (*ValueForStaticKey, error) {

	var err error

	o := featureXGetOptionContext{}
	for _, opt := range opts {
		opt(&o)
	}

	k, err := key.marshal()
	if err != nil {
		return nil, err
	}

	var v string
	switch {
	case o.del:
		v, err = s.r.GetDel(ctx, k).Result()
	case o.ttl != 0:
		v, err = s.r.GetEx(ctx, k, o.ttl).Result()
	case !o.exAt.IsZero():
		// TODO: PR to go-redis for exAt
		err = errors.New("exat is not supported by go-redis")
	default:
		v, err = s.r.Get(ctx, k).Result()
	}

	if err != nil {
		return nil, err
	}

	msg := &ValueForStaticKey{}
	err = msg.unmarshal(v)
	if err != nil {
		return nil, err
	}

	return msg, nil
}

func (s *featureXStorage) Set(ctx context.Context, key *StaticKey,
	value *ValueForStaticKey, opts ...FeatureXSetOption) (*ValueForStaticKey, error) {

	o := featureXSetOptionContext{
		get:     true,
		keepTTL: true,
	}
	for _, opt := range opts {
		opt(&o)
	}

	k, err := key.marshal()
	if err != nil {
		return nil, err
	}

	mv, err := value.marshal()
	if err != nil {
		return nil, err
	}

	v, err := s.r.SetArgs(ctx, k, mv, redis.SetArgs{
		Mode:     o.mode,
		TTL:      o.ttl,
		ExpireAt: o.exAt,
		Get:      o.get,
		KeepTTL:  o.keepTTL,
	}).Result()
	if err != nil && !errors.Is(err, redis.Nil) {
		return nil, err
	}

	if v != "" {
		msg := &ValueForStaticKey{}
		err = msg.unmarshal(v)
		if err != nil {
			return nil, err
		}
		return msg, nil
	}

	return nil, nil
}

func (s *featureXStorage) Del(ctx context.Context, key *StaticKey) error {

	k, err := key.marshal()
	if err != nil {
		return err
	}

	_, err = s.r.Del(ctx, k).Result()
	return err
}

// message marshallers

func (msg *StaticKey) marshal() (string, error) {

	v := fmt.Sprintf("feature-x:feature_x_enabled")

	return v, nil
}

func (msg *ValueForStaticKey) marshal() (string, error) {
	v, err := protojson.MarshalOptions{}.Marshal(msg)
	if err != nil {
		return "", err
	}

	return string(v), nil
}

func (msg *ValueForStaticKey) unmarshal(value string) error {
	return protojson.UnmarshalOptions{}.Unmarshal([]byte(value), msg)
}

// generated code for OnlineSessions
// storage interface

type OnlineSessionsKVStore interface {
	Get(context.Context, *OnlineSessionsKey, ...OnlineSessionsGetOption) (*OnlineSessionsValue, error)
	Set(context.Context, *OnlineSessionsKey,
		*OnlineSessionsValue, ...OnlineSessionsSetOption) (*OnlineSessionsValue, error)
	Del(context.Context, *OnlineSessionsKey) error
	Incr(context.Context, *OnlineSessionsKey, int, ...OnlineSessionsIncrOption) (int, error)
}

// get options
type onlineSessionsGetOptionContext struct {
	ttl  time.Duration
	exAt time.Time
	del  bool
}

type OnlineSessionsGetOption func(o *onlineSessionsGetOptionContext)

func WithOnlineSessionsGetTTL(ttl time.Duration) OnlineSessionsGetOption {
	return func(o *onlineSessionsGetOptionContext) {
		o.ttl = ttl
		o.exAt = time.Time{}
		o.del = false
	}
}

func WithOnlineSessionsGetExpireAt(eat time.Time) OnlineSessionsGetOption {
	return func(o *onlineSessionsGetOptionContext) {
		o.exAt = eat
		o.ttl = 0
		o.del = false
	}
}

func WithOnlineSessionsDel() OnlineSessionsGetOption {
	return func(o *onlineSessionsGetOptionContext) {
		o.del = true
		o.ttl = 0
		o.exAt = time.Time{}
	}
}

// set options
type onlineSessionsSetOptionContext struct {
	ttl     time.Duration
	exAt    time.Time
	mode    string
	get     bool
	keepTTL bool
}

type OnlineSessionsSetOption func(o *onlineSessionsSetOptionContext)

func WithOnlineSessionsSetOnlyIfNotExists() OnlineSessionsSetOption {
	return func(o *onlineSessionsSetOptionContext) {
		o.mode = "NX"
	}
}

func WithOnlineSessionsSetOnlyIfAlreadyExists() OnlineSessionsSetOption {
	return func(o *onlineSessionsSetOptionContext) {
		o.mode = "XX"
	}
}

func WithOnlineSessionsRetieveDisabled() OnlineSessionsSetOption {
	return func(o *onlineSessionsSetOptionContext) {
		o.get = false
	}
}

func WithOnlineSessionsSetTTL(ttl time.Duration) OnlineSessionsSetOption {
	return func(o *onlineSessionsSetOptionContext) {
		o.ttl = ttl
		o.exAt = time.Time{}
		o.keepTTL = false
	}
}

func WithOnlineSessionsSetExpireAt(eat time.Time) OnlineSessionsSetOption {
	return func(o *onlineSessionsSetOptionContext) {
		o.exAt = eat
		o.ttl = 0
		o.keepTTL = false
	}
}

// incr options
type onlineSessionsIncrOptionContext struct {
	ttl     time.Duration
	exAt    time.Time
	keepTTL bool
}

type OnlineSessionsIncrOption func(o *onlineSessionsIncrOptionContext)

func WithOnlineSessionsIncrTTL(ttl time.Duration, keepTTL bool) OnlineSessionsIncrOption {
	return func(o *onlineSessionsIncrOptionContext) {
		o.ttl = ttl
		o.keepTTL = keepTTL
		o.exAt = time.Time{}
	}
}

func WithOnlineSessionsIncrExpireAt(eat time.Time) OnlineSessionsIncrOption {
	return func(o *onlineSessionsIncrOptionContext) {
		o.exAt = eat
		o.ttl = 0
		o.keepTTL = false
	}
}

// storage construction

func NewOnlineSessionsStore(r redis.Cmdable, opts ...onlineSessionsOption) OnlineSessionsKVStore {
	oc := onlineSessionsOptionContext{}

	for _, opt := range opts {
		opt(&oc)
	}

	return &onlineSessionsStorage{
		r:    r,
		opts: oc,
	}
}

type onlineSessionsOptionContext struct{}

type onlineSessionsOption func(o *onlineSessionsOptionContext)

// storage implementation

type onlineSessionsStorage struct {
	r    redis.Cmdable
	opts onlineSessionsOptionContext
}

func (s *onlineSessionsStorage) Get(
	ctx context.Context, key *OnlineSessionsKey, opts ...OnlineSessionsGetOption) (*OnlineSessionsValue, error) {

	var err error

	o := onlineSessionsGetOptionContext{}
	for _, opt := range opts {
		opt(&o)
	}

	k, err := key.marshal()
	if err != nil {
		return nil, err
	}

	var v string
	switch {
	case o.del:
		v, err = s.r.GetDel(ctx, k).Result()
	case o.ttl != 0:
		v, err = s.r.GetEx(ctx, k, o.ttl).Result()
	case !o.exAt.IsZero():
		// TODO: PR to go-redis for exAt
		err = errors.New("exat is not supported by go-redis")
	default:
		v, err = s.r.Get(ctx, k).Result()
	}

	if err != nil {
		return nil, err
	}

	msg := &OnlineSessionsValue{}
	err = msg.unmarshal(v)
	if err != nil {
		return nil, err
	}

	return msg, nil
}

func (s *onlineSessionsStorage) Set(ctx context.Context, key *OnlineSessionsKey,
	value *OnlineSessionsValue, opts ...OnlineSessionsSetOption) (*OnlineSessionsValue, error) {

	o := onlineSessionsSetOptionContext{
		get:     true,
		keepTTL: true,
	}
	for _, opt := range opts {
		opt(&o)
	}

	k, err := key.marshal()
	if err != nil {
		return nil, err
	}

	mv, err := value.marshal()
	if err != nil {
		return nil, err
	}

	v, err := s.r.SetArgs(ctx, k, mv, redis.SetArgs{
		Mode:     o.mode,
		TTL:      o.ttl,
		ExpireAt: o.exAt,
		Get:      o.get,
		KeepTTL:  o.keepTTL,
	}).Result()
	if err != nil && !errors.Is(err, redis.Nil) {
		return nil, err
	}

	if v != "" {
		msg := &OnlineSessionsValue{}
		err = msg.unmarshal(v)
		if err != nil {
			return nil, err
		}
		return msg, nil
	}

	return nil, nil
}

func (s *onlineSessionsStorage) Del(ctx context.Context, key *OnlineSessionsKey) error {

	k, err := key.marshal()
	if err != nil {
		return err
	}

	_, err = s.r.Del(ctx, k).Result()
	return err
}

func (s *onlineSessionsStorage) Incr(ctx context.Context,
	key *OnlineSessionsKey, by int, opts ...OnlineSessionsIncrOption) (int, error) {

	o := onlineSessionsIncrOptionContext{}
	for _, opt := range opts {
		opt(&o)
	}

	k, err := key.marshal()
	if err != nil {
		return 0, err
	}

	v, err := s.r.IncrBy(ctx, k, int64(by)).Result()
	if err != nil {
		return 0, err
	}

	switch {
	case o.ttl != 0:
		if o.keepTTL {
			_, err = s.r.ExpireNX(ctx, k, o.ttl).Result()
		} else {
			_, err = s.r.Expire(ctx, k, o.ttl).Result()
		}
	case !o.exAt.IsZero():
		_, err = s.r.ExpireAt(ctx, k, o.exAt).Result()
	}

	return int(v), err
}

// message marshallers

func (msg *OnlineSessionsKey) marshal() (string, error) {

	v := fmt.Sprintf("online-sessions:counter")

	return v, nil
}

func (msg *OnlineSessionsValue) marshal() (string, error) {
	v, err := protojson.MarshalOptions{}.Marshal(msg)
	if err != nil {
		return "", err
	}

	return string(v), nil
}

func (msg *OnlineSessionsValue) unmarshal(value string) error {
	return protojson.UnmarshalOptions{}.Unmarshal([]byte(value), msg)
}

// generated code for RateLimit
// storage interface

type RateLimitKVStore interface {
	Get(context.Context, *DynamicKey, ...RateLimitGetOption) (*RateLimitCount, error)
	Set(context.Context, *DynamicKey,
		*RateLimitCount, ...RateLimitSetOption) (*RateLimitCount, error)
	Del(context.Context, *DynamicKey) error
}

// get options
type rateLimitGetOptionContext struct {
	ttl  time.Duration
	exAt time.Time
	del  bool
}

type RateLimitGetOption func(o *rateLimitGetOptionContext)

func WithRateLimitGetTTL(ttl time.Duration) RateLimitGetOption {
	return func(o *rateLimitGetOptionContext) {
		o.ttl = ttl
		o.exAt = time.Time{}
		o.del = false
	}
}

func WithRateLimitGetExpireAt(eat time.Time) RateLimitGetOption {
	return func(o *rateLimitGetOptionContext) {
		o.exAt = eat
		o.ttl = 0
		o.del = false
	}
}

func WithRateLimitDel() RateLimitGetOption {
	return func(o *rateLimitGetOptionContext) {
		o.del = true
		o.ttl = 0
		o.exAt = time.Time{}
	}
}

// set options
type rateLimitSetOptionContext struct {
	ttl     time.Duration
	exAt    time.Time
	mode    string
	get     bool
	keepTTL bool
}

type RateLimitSetOption func(o *rateLimitSetOptionContext)

func WithRateLimitSetOnlyIfNotExists() RateLimitSetOption {
	return func(o *rateLimitSetOptionContext) {
		o.mode = "NX"
	}
}

func WithRateLimitSetOnlyIfAlreadyExists() RateLimitSetOption {
	return func(o *rateLimitSetOptionContext) {
		o.mode = "XX"
	}
}

func WithRateLimitRetieveDisabled() RateLimitSetOption {
	return func(o *rateLimitSetOptionContext) {
		o.get = false
	}
}

func WithRateLimitSetTTL(ttl time.Duration) RateLimitSetOption {
	return func(o *rateLimitSetOptionContext) {
		o.ttl = ttl
		o.exAt = time.Time{}
		o.keepTTL = false
	}
}

func WithRateLimitSetExpireAt(eat time.Time) RateLimitSetOption {
	return func(o *rateLimitSetOptionContext) {
		o.exAt = eat
		o.ttl = 0
		o.keepTTL = false
	}
}

// storage construction

func NewRateLimitStore(r redis.Cmdable, opts ...rateLimitOption) RateLimitKVStore {
	oc := rateLimitOptionContext{}

	for _, opt := range opts {
		opt(&oc)
	}

	return &rateLimitStorage{
		r:    r,
		opts: oc,
	}
}

type rateLimitOptionContext struct{}

type rateLimitOption func(o *rateLimitOptionContext)

// storage implementation

type rateLimitStorage struct {
	r    redis.Cmdable
	opts rateLimitOptionContext
}

func (s *rateLimitStorage) Get(
	ctx context.Context, key *DynamicKey, opts ...RateLimitGetOption) (*RateLimitCount, error) {

	var err error

	o := rateLimitGetOptionContext{}
	for _, opt := range opts {
		opt(&o)
	}

	k, err := key.marshal()
	if err != nil {
		return nil, err
	}

	var v string
	switch {
	case o.del:
		v, err = s.r.GetDel(ctx, k).Result()
	case o.ttl != 0:
		v, err = s.r.GetEx(ctx, k, o.ttl).Result()
	case !o.exAt.IsZero():
		// TODO: PR to go-redis for exAt
		err = errors.New("exat is not supported by go-redis")
	default:
		v, err = s.r.Get(ctx, k).Result()
	}

	if err != nil {
		return nil, err
	}

	msg := &RateLimitCount{}
	err = msg.unmarshal(v)
	if err != nil {
		return nil, err
	}

	return msg, nil
}

func (s *rateLimitStorage) Set(ctx context.Context, key *DynamicKey,
	value *RateLimitCount, opts ...RateLimitSetOption) (*RateLimitCount, error) {

	o := rateLimitSetOptionContext{
		get:     true,
		keepTTL: true,
	}
	for _, opt := range opts {
		opt(&o)
	}

	k, err := key.marshal()
	if err != nil {
		return nil, err
	}

	mv, err := value.marshal()
	if err != nil {
		return nil, err
	}

	v, err := s.r.SetArgs(ctx, k, mv, redis.SetArgs{
		Mode:     o.mode,
		TTL:      o.ttl,
		ExpireAt: o.exAt,
		Get:      o.get,
		KeepTTL:  o.keepTTL,
	}).Result()
	if err != nil && !errors.Is(err, redis.Nil) {
		return nil, err
	}

	if v != "" {
		msg := &RateLimitCount{}
		err = msg.unmarshal(v)
		if err != nil {
			return nil, err
		}
		return msg, nil
	}

	return nil, nil
}

func (s *rateLimitStorage) Del(ctx context.Context, key *DynamicKey) error {

	k, err := key.marshal()
	if err != nil {
		return err
	}

	_, err = s.r.Del(ctx, k).Result()
	return err
}

// message marshallers

func (msg *DynamicKey) marshal() (string, error) {

	v := fmt.Sprintf("rate-limit:%v:%v:%v", msg.RpcName, msg.CallerId, msg.Bucket)

	return v, nil
}

func (msg *RateLimitCount) marshal() (string, error) {
	v, err := protojson.MarshalOptions{}.Marshal(msg)
	if err != nil {
		return "", err
	}

	return string(v), nil
}

func (msg *RateLimitCount) unmarshal(value string) error {
	return protojson.UnmarshalOptions{}.Unmarshal([]byte(value), msg)
}
