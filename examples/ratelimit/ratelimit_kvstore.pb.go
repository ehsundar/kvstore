// Code generated by protoc-gen-go-kvstore . DO NOT EDIT.

package ratelimit

import (
	"context"
	"errors"
	"fmt"
	"strconv"

	"github.com/ehsundar/kvstore"
	"github.com/redis/go-redis/v9"
	"google.golang.org/protobuf/encoding/protojson"
)

// generated code for Dummy
// storage interface

type DummyKVStore interface {
	Get(context.Context, *DummyKey, ...kvstore.GetOption) (*DummyValue, error)
	Set(context.Context, *DummyKey,
		*DummyValue, ...kvstore.SetOption) (*DummyValue, error)
	Del(context.Context, *DummyKey) error
}

// storage construction

func NewDummyStore(r redis.Cmdable, opts ...kvstore.InitOption) DummyKVStore {

	oc := kvstore.InitOptionContext{}
	for _, opt := range opts {
		opt(&oc)
	}

	return &dummyStorage{
		r:    r,
		opts: oc,
	}
}

// storage implementation

type dummyStorage struct {
	r    redis.Cmdable
	opts kvstore.InitOptionContext
}

func (s *dummyStorage) Get(
	ctx context.Context, key *DummyKey, opts ...kvstore.GetOption) (*DummyValue, error) {

	var err error

	o := kvstore.GetOptionContext{}
	for _, opt := range opts {
		opt(&o)
	}

	k, err := key.marshal()
	if err != nil {
		return nil, err
	}

	var v string
	switch {
	case o.Del:
		v, err = s.r.GetDel(ctx, k).Result()
	case o.TTL != 0:
		v, err = s.r.GetEx(ctx, k, o.TTL).Result()
	case !o.ExAt.IsZero():
		// TODO: PR to go-redis for exAt
		err = errors.New("exat is not supported by go-redis")
	default:
		v, err = s.r.Get(ctx, k).Result()
	}

	if err != nil {
		return nil, err
	}

	msg := &DummyValue{}
	err = msg.unmarshal(v)
	if err != nil {
		return nil, err
	}

	return msg, nil
}

func (s *dummyStorage) Set(ctx context.Context, key *DummyKey,
	value *DummyValue, opts ...kvstore.SetOption) (*DummyValue, error) {

	o := kvstore.SetOptionContext{
		Get:     true,
		KeepTTL: true,
	}
	for _, opt := range opts {
		opt(&o)
	}

	k, err := key.marshal()
	if err != nil {
		return nil, err
	}

	mv, err := value.marshal()
	if err != nil {
		return nil, err
	}

	v, err := s.r.SetArgs(ctx, k, mv, redis.SetArgs{
		Mode:     o.Mode,
		TTL:      o.TTL,
		ExpireAt: o.ExAt,
		Get:      o.Get,
		KeepTTL:  o.KeepTTL,
	}).Result()
	if err != nil && !errors.Is(err, redis.Nil) {
		return nil, err
	}

	if v != "" {
		msg := &DummyValue{}
		err = msg.unmarshal(v)
		if err != nil {
			return nil, err
		}
		return msg, nil
	}

	return nil, nil
}

func (s *dummyStorage) Del(ctx context.Context, key *DummyKey) error {

	k, err := key.marshal()
	if err != nil {
		return err
	}

	_, err = s.r.Del(ctx, k).Result()
	return err
}

// message marshallers

func (msg *DummyKey) marshal() (string, error) {

	v := fmt.Sprintf("dummy:dummy")

	return v, nil
}

func (msg *DummyValue) marshal() (string, error) {
	v, err := protojson.MarshalOptions{}.Marshal(msg)
	if err != nil {
		return "", err
	}

	return string(v), nil
}

func (msg *DummyValue) unmarshal(value string) error {
	return protojson.UnmarshalOptions{}.Unmarshal([]byte(value), msg)
}

// generated code for RateLimit
// storage interface

type RateLimitKVStore interface {
	Get(context.Context, *CallInfo, ...kvstore.GetOption) (int64, error)
	Set(context.Context, *CallInfo,
		int64, ...kvstore.SetOption) (int64, error)
	Del(context.Context, *CallInfo) error
	Incr(context.Context, *CallInfo, int64, ...kvstore.IncrOption) (int64, error)
}

// storage construction

func NewRateLimitStore(r redis.Cmdable, opts ...kvstore.InitOption) RateLimitKVStore {

	oc := kvstore.InitOptionContext{}
	for _, opt := range opts {
		opt(&oc)
	}

	return &rateLimitStorage{
		r:    r,
		opts: oc,
	}
}

// storage implementation

type rateLimitStorage struct {
	r    redis.Cmdable
	opts kvstore.InitOptionContext
}

func (s *rateLimitStorage) Get(
	ctx context.Context, key *CallInfo, opts ...kvstore.GetOption) (int64, error) {

	var err error

	o := kvstore.GetOptionContext{}
	for _, opt := range opts {
		opt(&o)
	}

	k, err := key.marshal()
	if err != nil {
		return 0, err
	}

	var v string
	switch {
	case o.Del:
		v, err = s.r.GetDel(ctx, k).Result()
	case o.TTL != 0:
		v, err = s.r.GetEx(ctx, k, o.TTL).Result()
	case !o.ExAt.IsZero():
		// TODO: PR to go-redis for exAt
		err = errors.New("exat is not supported by go-redis")
	default:
		v, err = s.r.Get(ctx, k).Result()
	}

	if err != nil {
		return 0, err
	}

	return strconv.ParseInt(v, 10, 64)

}

func (s *rateLimitStorage) Set(ctx context.Context, key *CallInfo,
	value int64, opts ...kvstore.SetOption) (int64, error) {

	o := kvstore.SetOptionContext{
		Get:     true,
		KeepTTL: true,
	}
	for _, opt := range opts {
		opt(&o)
	}

	k, err := key.marshal()
	if err != nil {
		return 0, err
	}

	mv := fmt.Sprintf("%v", value)
	v, err := s.r.SetArgs(ctx, k, mv, redis.SetArgs{
		Mode:     o.Mode,
		TTL:      o.TTL,
		ExpireAt: o.ExAt,
		Get:      o.Get,
		KeepTTL:  o.KeepTTL,
	}).Result()
	if err != nil && !errors.Is(err, redis.Nil) {
		return 0, err
	}

	if v != "" {

		return strconv.ParseInt(v, 10, 64)

	}

	return 0, nil
}

func (s *rateLimitStorage) Del(ctx context.Context, key *CallInfo) error {

	k, err := key.marshal()
	if err != nil {
		return err
	}

	_, err = s.r.Del(ctx, k).Result()
	return err
}

func (s *rateLimitStorage) Incr(ctx context.Context,
	key *CallInfo, by int64, opts ...kvstore.IncrOption) (int64, error) {

	o := kvstore.IncrOptionContext{}
	for _, opt := range opts {
		opt(&o)
	}

	k, err := key.marshal()
	if err != nil {
		return 0, err
	}

	v, err := s.r.IncrBy(ctx, k, by).Result()
	if err != nil {
		return 0, err
	}

	switch {
	case o.TTL != 0:
		if o.KeepTTL {
			_, err = s.r.ExpireNX(ctx, k, o.TTL).Result()
		} else {
			_, err = s.r.Expire(ctx, k, o.TTL).Result()
		}
	case !o.ExAt.IsZero():
		_, err = s.r.ExpireAt(ctx, k, o.ExAt).Result()
	}

	return v, err
}

// message marshallers

func (msg *CallInfo) marshal() (string, error) {

	v := fmt.Sprintf("rate-limit:%v:%v:%v", msg.PathName, msg.CallerId, msg.TimeBucket)

	return v, nil
}

func (msg *CallRate) marshal() (string, error) {
	v, err := protojson.MarshalOptions{}.Marshal(msg)
	if err != nil {
		return "", err
	}

	return string(v), nil
}

func (msg *CallRate) unmarshal(value string) error {
	return protojson.UnmarshalOptions{}.Unmarshal([]byte(value), msg)
}
